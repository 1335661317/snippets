# 最大子段和

## **描述**

> N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。
>
> 例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。



## **Input**

> 第1行：整数序列的长度N（2 <= N <= 50000)
>
> 第2 - N + 1行：N个整数（-10^9 <= A[i] <= 10^9）



## **Output**

> 输出最大子段和。



## **Input示例**

    6
    -2
    11
    -4
    13
    -5
    -2



## **Output示例**

    20



## **思路**

动态规划的基础题目，求最大子段和。

可以用 `dp[i]` 代表以 `i` 为结尾的前 `i` 个元素的最大子段和，那么当 `dp[i-1]>0` 时，显然加上它可以获得更大的和，当 `dp[i-1]<0` 时，我们就可以舍弃前面的子段啦！重新开始新的一段。



## **AC 代码**

```cpp
#include<iostream>
using namespace std;
__int64 a[50005],dp[50005],s;
int main()
{
    int n;
    cin>>n;
    for(int i=1; i<=n; i++)
        cin>>a[i];
    for(int i=1; i<=n; i++)
    {
        if(dp[i-1]>0)dp[i]=dp[i-1]+a[i];
        else dp[i]=a[i];
        s=max(dp[i],s);
    }
    cout<<s<<endl;
    return 0;
}
```

