# 渗透学习 - 工具篇之目标识别

## **状态识别**

在渗透测试的过程中，必须确保目标主机在线，否则我们无法访问到它。

### **ping**

常用检测主机是否在线的程序。ICMP协议，`echo request` -> `echo reply`



`-c count` 指定发送 `echo request` 数据包总量。

```
root@kali:~# ping -c 5 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=128 time=1.95 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=128 time=2.30 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=128 time=3.55 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=128 time=2.02 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=128 time=2.60 ms

--- 192.168.1.1 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4017ms
rtt min/avg/max/mdev = 1.959/2.488/3.552/0.581 ms
```

`-s packet size` 每个数据包的大小。默认值56，加 ICMP 包头8字节共64字节。

```
root@kali:~# ping -s 8 192.168.1.1 -c 1
PING 192.168.1.1 (192.168.1.1) 8(36) bytes of data.
16 bytes from 192.168.1.1: icmp_seq=1 ttl=128

--- 192.168.1.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
```



### **arping**

***局域网***中使用ARP请求判断主机是否在线。

```
root@kali:~# arping 192.168.43.130 -c 2
ARPING 192.168.43.130
60 bytes from 00:0c:29:fa:dd:2a (192.168.43.130): index=0 time=193.037 usec
60 bytes from 00:0c:29:fa:dd:2a (192.168.43.130): index=1 time=389.499 usec

--- 192.168.43.130 statistics ---
2 packets transmitted, 2 packets received,   0% unanswered (0 extra)
rtt min/avg/max/std-dev = 0.193/0.291/0.389/0.098 ms
```

因为是在局域网中的判断，所以我们也可以用它来检测某一个IP是否已经被被人所占用，如果没有被占用的话……[斜眼笑]



### **fping**

可同时向多个主机发送 `ping` 请求。

```
root@kali:~# fping 192.168.1.1 192.168.1.2
192.168.1.1 is alive
192.168.1.2 is unreachable
```

或者对某一个网段进行检测

```
root@kali:~# fping -g 192.168.1.0/24
192.168.1.1 is alive
192.168.1.103 is alive
ICMP Host Unreachable from 192.168.1.109 for ICMP Echo sent to 192.168.1.92
192.168.1.2 is unreachable
192.168.1.3 is unreachable
...
```

如果我们不添加任何条件的时候，在进行网段检测时， `0-255` 会被重试三次，然后便会输出好长好长的一段信息。

通过 `-r count` 参数可以指定 `fping` 探测的重试次数。



### **nping**

允许用户发送多种协议的数据包。（TCP、UDP、ICMP、ARP）

```
EXAMPLES:
  nping scanme.nmap.org
  nping --tcp -p 80 --flags rst --ttl 2 192.168.1.1
  nping --icmp --icmp-type time --delay 500ms 192.168.254.254
  nping --echo-server "public" -e wlan0 -vvv 
  nping --echo-client "public" echo.nmap.org --tcp -p1-1024 --flags ack
```

例如使用TCP协议对 `192.168.1.1` 的22端口进行测试

```
root@kali:~# nping --tcp -p 22 192.168.1.1 

Starting Nping 0.7.25BETA1 ( https://nmap.org/nping ) at 2017-02-10 16:24 CST
SENT (0.0284s) TCP 192.168.43.128:23660 > 192.168.1.1:22 S ttl=64 id=20665 iplen=40  seq=1842129984 win=1480 
SENT (1.0294s) TCP 192.168.43.128:23660 > 192.168.1.1:22 S ttl=64 id=20665 iplen=40  seq=1842129984 win=1480 
^C 
Max rtt: N/A | Min rtt: N/A | Avg rtt: N/A
Raw packets sent: 2 (80B) | Rcvd: 0 (0B) | Lost: 2 (100.00%)
Nping done: 1 IP address pinged in 1.64 seconds
```



## **操作系统识别**

确定目标主机在线以后，我们需要判断它使用哪种操作系统。

识别操作系统的方式有两种：主动式与被动式。

**主动式：**向目标主机发送数据包，并根据其响应判断其操作系统。优点：速度快。缺点：容易被发现。

**被动式：**通过网络嗅探的方式收集流经网络的数据报文，然后从这些报文中分析并得出操作系统信息。优点：不容易被发现。缺点：速度慢。

### **p0f**

采用被动的方式探测目标主机的操作系统类型，可识别以下几种主机：

- 连接到你的主机的机器（SYN）
- 你可以访问的机器（SYN+ACK）
- 不能访问的机器（RST）
- 其他网络通信的机器

启动 `p0f` 然后与目标主机建立TCP连接，若成功识别目标主机的操作系统，则会在屏幕输出相应的信息。



### **Nmap**

这是一款非常受欢迎的端口扫描工具，并且可以用来识别主机的操作系统类型。

`nmap -O 192.168.1.1`

```
Running: Linux 2.6.X
OS CPE: cpe:/o:linux:linux_kernel:2.6
OS details: Linux 2.6.9 - 2.6.33
```
