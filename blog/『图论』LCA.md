# 『图论』LCA

## **概述篇**

LCA (Least Common Ancestors) ，即最近公共祖先，是指这样的一个问题：在有根树中，找出某两个节点 `u` 和 `v` 最近的公共祖先。



LCA 可分为**在线算法**与**离线算法**

- **在线算法：**指程序可以以序列化的方式一个一个处理输入，也就是说在一开始并不需要知道所有的输入。
- **离线算法：**指一开始就需要知道问题的所有输入数据，而在解决一个问题后立即输出结果。




## **算法篇**

对于该问题，很容易想到的做法是从 `u、v` 分别回溯到根节点，然后这两条路径中的第一个交点即为 `u、v` 的最近公共祖先，在一棵平衡二叉树中，该算法的时间复杂度可以达到 $O(\log n)$ ，但是对于某些退化为链状的树来说，算法的时间复杂度为 $O(n)$ ，显然无法满足更高频率的查询。



本节介绍几种比较高效的算法来解决这个问题，常见的算法有三种：在线 dfs + ST 算法、倍增算法、离线 Tarjan 算法。

接下来我们来一一解释这三种 `/* 看似高深,其实也不简单 */` 的算法。

**前方多图么？千千也不知道，要不要发出警告呢？(；′⌒`) （逃**



### **在线 DFS + ST 算法**

首先看到 `ST` 你会想到什么呢？（脑补许久都没有想到会是哪个单词的缩写）

看过前文 [『数据结构』RMQ 问题](https://www.dreamwings.cn/rmq/4788.html) 的话你便可以明白 `ST算法` 的思路啦~

So ，关于 LCA 的这种在线算法也是可以建立在 RMQ 问题的基础上咯~

我们设 `LCA(T,u,v)` 为在有根树 `T` 中节点 `u、v` 的最近公共祖先， `RMQ(A,i,j)` 为线性序列 `A` 中区间 `[i,j]` 上的最小（大）值。



**如下图这棵有根树：**

![img](https://www.dreamwings.cn/wp-content/uploads/2017/08/lca_0.png)



**我们令节点编号满足父节点编号小于子节点编号（编号条件）**，可以看出 `LCA(T,4,5)=2,LCA(T,2,8)=1,LCA(T,3,9)=3` 。

设线性序列 `A` 为有根树 `T` 的中序遍历，即 `A = [4,2,5,1,8,6,9,3,7]` 。

由中序遍历的性质我们可以知道，任意两点 `u、v` 的最近公共祖先总在以该两点所在位置为端点的区间内，且编号最小。



**举个栗子：**

假设 `u = 8,v = 7` ，则该两点所确定的一段区间为 `[8,6,9,3,7]` ，而区间最小值为 `3` ，也就是说，节点 `3` 为 `u、v` 的最近公共祖先。

解决区间最值问题我们可以采用 RMQ 问题中的 `ST 算法` 。



但是在有些问题中给出的节点并不一定满足我们所说的父节点编号小于子节点编号，因此我们可以利用节点间的关系建图，然后采用前序遍历来为每一个节点重新编号以生成线性序列 `A` ，于是问题又被转化为了区间最值的查询，和之前一样的做法咯，总的时间复杂度： $n×O(\log n)$ 的预处理 `+` $O(1)$ 的查询。

想了解 `RMQ 问题` 的解法可以戳上面的链接哦~

---

以上部分介绍了 LCA 如何转化为 RMQ 问题，而在实际中这两种方案之间可以相互转化

类比之前的做法，我们如何将一个线性序列转化为满足**编号条件**的有根树？

1. 设序列中的最小值为 $A_k$ ，建立优先级为 $A_k$ 的根节点 $T_k$
2. 将 $A[1...k-1]$ 递归建树作为 $T_k$ 的左子树
3. 将 $A[k+1...n]$ 递归建树作为 $T_k$ 的右子树

读者可以试着利用此方法将之前的线性序列 `A = [4,2,5,1,8,6,9,3,7]` 构造出有根树 `T` ，结果一定满足之前所说的**编号条件**，但不一定唯一。



### **离线 Tarjan 算法**

Tarjan 算法是一种常见的用于解决 LCA 问题的离线算法，它结合了深度优先搜索与并查集，整个算法为线性处理时间。



**首先来介绍一下 Tarjan 算法的基本思路：**

1. 任选一个节点为根节点，从根节点开始
2. 遍历该点 u 的所有子节点 v ，并标记 v 已经被访问过
3. 若 v 还有子节点，返回 2 ，否则下一步
4. 合并 v 到 u 所在集合
5. 寻找与当前点 u 有询问关系的点 e
6. 若 e 已经被访问过，则可以确定 u、e 的最近公共祖先为 e 被合并到的父亲节点



**伪代码：**

```cpp
Tarjan(u)               // merge 和 find 为并查集合并函数和查找函数
{
    for each(u,v)       // 遍历 u 的所有子节点 v
    {
        Tarjan(v);      // 继续往下遍历
        merge(u,v);     // 合并 v 到 u 这一集合
        标记v被访问过;
    }
    for each(u,e)       // 遍历所有与 u 有查询关系的 e
    {
        如果 e 被访问过;
        u,e 的最近公共祖先为 find(e) ;
    }
}
```



感觉说到这里好像没有其他东西



### **倍增算法**

未完待续 -ing



## **总结**

