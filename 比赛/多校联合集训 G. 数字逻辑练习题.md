# 数字逻辑练习题

## **题目描述**

> 原码、反码、补码都是一样的，都是正数本身。 
>
> 对于负数：
>
> 原码是符号位为 1，数值部分取绝对值的二进制。 
>
> 反码是符号位为 1，其它位是原码取反。 
>
> 补码是符号位为 1，其它位是原码取反,未位加 1。 
>
> 输入一个 64bit 十进制整数，输出它的原码，反码，补码的 16 进制表示法 



## **输入**

> 有多组数据，每组数据一行，为一个 64bit 十进制整数，包含正负符号和数值，格式见样例。 
>
> 输入保证有唯一原码，反码，补码对应。 



## **输出**

> 每组输出三个 16 进制数，分别为原码，反码，补码。 



## **样例输入**

    +1
    -1
    +10086
    -2333333



## **样例输出**

    0x0000000000000001
    0x0000000000000001
    0x0000000000000001
    0x8000000000000001
    0xfffffffffffffffe
    0xffffffffffffffff
    0x0000000000002766
    0x0000000000002766
    0x0000000000002766
    0x8000000000239a95
    0xffffffffffdc656a
    0xffffffffffdc656b



## **思路**

对于正数，它的原反补码都是一样的，直接按照格式输出即可。

对于负数，我们可以用 $2^{64}$ 与原数进行某些运算得出原反补码，因为涉及到了大数，本来想用 `java` 写的，不过发现可以用 `python` 提交，于是万千 `C/C++` 中出现了我一个特例。

![img](https://www.dreamwings.cn/wp-content/uploads/2017/05/1641872833.png)

**PS:** 输入有可能会有 `-0` 的情况，而它的原反补码并不等于 `+0` 。



## **AC 代码**

```python
while True:
    try:
        T = raw_input()
        if len(T.strip()) == 0:
            continue
        if T == '-0':
            print '0x8000000000000000'
            print '0xffffffffffffffff'
            print '0x0000000000000000'
            continue
        T = int(T)
        if T >= 0:
            print '%#018x' % T
            print '%#018x' % T
            print '%#018x' % T
        else:
            print '%#018x' % (0x8000000000000000 | -T)
            print '%#018x' % (2 ** 64 - 1 + T)
            print '%#018x' % (2 ** 64 - 1 + T + 1)
    except EOFError:
        break
```

